Class Loader

				Loading										   Linking	
			---------------------						------------------------		


			BootStrap Class Loader          					Verification   
					
			      |													|
				  |													|
			Extension Class Loader		 -->				    Prefaration				   -->  Initilizing 				
			
			      |													|
				  |													|	
			Application Class Loader							 Resolution
			
			
			
Java ClassLoader is based on three principles: Delegation, Visibility, and Uniqueness.

			
Bootstrap ClassLoader – It loads JDK internal classes, typically loads rt.jar and other core classes.
Extensions Class Loader – It loads classes from the JDK extensions directory, usually $JAVA_HOME/lib/ext directory.
System Class Loader – It loads classes from the current classpath that can be set while invoking a program using -cp or -classpath command-line options.			


Verification: It ensures the correctness of the .class file i.e. it checks whether this file is properly formatted and generated by a valid compiler or not. If verification fails, we get run-time exception java.lang.VerifyError. 

Preparation: JVM allocates memory for class variables and initializing the memory to default values.

Resolution: All symbolic references that were now loaded into the method area in form of the runtime constant pool are resolved to actual types loaded by  JVM. If a symbolic reference can be resolved but results in a conflict of definitions, a IncompatibleClassChangeError is thrown. If a referenced class cannot be found, a NoClassDefFoundError is thrown which basically wraps a ClassNotFoundException that was thrown by the class loader attempting to load this referenced class. If a referenced class references itself, a ClassCircularityError is thrown. Resolution can happen in one of two flavors which is up to the implementors of the JVM

Eager: All symbolic references to other fields, methods or classes are resolved right now.

Lazy: Resolving of symbolic references is postponed until the first use of a method. This might bring with it that a class refering to a non-existant class never throws an error if this reference never needs to be resolved.



Initialization: In this phase, all static variables are assigned with their values defined in the code and static block(if any). This is executed from top to bottom in a class and from parent to child in the class hierarchy. 